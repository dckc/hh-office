#!/usr/bin/env python
'''Handle web requests for printed reports from a database.

'''

import sys
import ConfigParser
import datetime
from os import path
import wsgiref.handlers
import traceback

from lxml import etree  # ubuntu python-lxml 2.2.4-1
                        # MD5sum: 0db8703d05c67d04c854ce44ab466625
                        # http://lxml.de/index.html

import rlib  # http://rlib.sicompos.com/
             # 06b3e629c6f99a8b2fd1264f32db8f56  rlib-1.3.7.tar.gz

PLAIN = [('Content-Type', 'text/plain')]
HTML8 = [('Content-Type', 'text/html; charset=utf-8')]
PDF = [('Content-Type', 'application/pdf')]


def cgi_main():
    report = rlib.Rlib()
    h = report_handler(report)
    wsgiref.handlers.CGIHandler().run(h)


def report_handler(report, tx='reportspec.xsl'):
    '''Build a report handler from a report.

    @param report: from rlib__
    @param tx: filename of an XSLT transformation that produces
               `rlib report definitions`__ from HTML skeletons.

    @return: a WSGI app, i.e. f(e, sr) that produces the report
             using :func:`serve_report_request`.

    __ http://rlib.sicompos.com/
    __ http://newrlib.sicom.com/~rlib/index.php/Documentation_XML

    '''
    def handle(env, start_response):
        try:
            return serve_report_request(env, start_response, report, tx)
        except:
            start_response('500 internal error', PLAIN)
            return [traceback.format_exc()]

    return handle


def serve_report_request(env, start_response, report, tx_file):
    '''Service a report request

    @param env: CGI environment; PATH_INFO is used to find
                a report skeleton under `templates`. See :func:`_asset`.
                The skeleton also specifies the mysql query to run
                in an element with @class="query".
    @param start_response: as per WSGI; called with 200 OK on
                           success or 404
                           in case no template is found.
                           The caller is responsible to make 5xx
                           responses out of any exceptions raised.
    @param report: an intilized rlib report.
    @param tx_file: transform filename, as per report_handler.

    See :func:`add_xataface_datasource` for database connection strategy.

    @return: an iterator as per WSGI; contains a PDF document
             in the success case or a message in the 404 case.

    .. todo: rename/unhide, document _asset()
    .. todo: cite WSGI
    '''

    tx = etree.XSLT(etree.parse(open(_asset(tx_file))))

    path_info = env.get('PATH_INFO', None)
    if not path_info:
        start_response('404 not found', PLAIN)
        return ['no report path given\n']

    try:
        skel_path = _asset('templates', path_info[1:] + '.html')
    except:
        start_response('404 not found', PLAIN)
        return ['no such report spec\n']

    skel = etree.parse(open(skel_path))
    report_dml = skel.xpath('//*[@class="query"]/text()')[0]
    _progress('report dml:', report_dml)
    spec = tx(skel)
    spec_txt = etree.tostring(spec)

    dsn = "local_mysql"
    add_xataface_datasource(report, dsn)
    report.add_query_as(dsn, report_dml, 'arbitrary_report_name')
    report.add_report_from_buffer(spec_txt)
    report.set_output_format_from_text("PDF")

    # todo: try different font:
    # report.set_output_parameter("pdf_fontname", 'helvetica')

    # I'm trying to get rid of:
    # encoding is NULL or invalid [C]... using en_US
    # but this doesn't seem to change anything.
    # myreport.set_output_encoding('UTF-8')
    report.execute()

    _progress('raw headers: ', report.get_content_type_as_text())
    hd_txt = report.get_content_type_as_text()
    hdrs = [tuple(line.strip().split(': ', 1))
            for line in hd_txt.split('\n')[:-1]]  # skip head/body separator
    _progress('parsed headers: ', hdrs)
    start_response('200 ok', hdrs)
    return [report.get_output()]


def _asset(*paths):
    abspath = path.join(path.dirname(__file__), *paths)
    if not path.exists(abspath):
        raise IOError('no such file: ' + abspath)
    return abspath


def _progress(*args):
    import sys
    sys.stderr.write(' '.join([str(a) for a in args]) + '\n')


def add_xataface_datasource(report, dsn,
                            ini='conf.ini', section='_database'):
    '''Add a mysql datasource to a report following xataface conventions.

    @param report: an rlib.Rlib
    @param dsn: a name for the datasource, per the rlib API
    @param ini: `conf.ini`, per `xataface docs`__
    @param section: `_database`, per xataface

    __ http://xataface.com/wiki/conf.ini_file
    '''
    opts = ConfigParser.SafeConfigParser()
    opts.read(_asset(ini))

    def opt(n):
        v = opts.get(section, n)
        return v[1:-1]  # strip ""s

    report.add_datasource_mysql(dsn, opt('host'), opt('user'),
                                opt('password'), opt('name'))

if __name__ == '__main__':
    cgi_main()
