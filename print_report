#!/usr/bin/env python
'''Handle web requests for printed reports from a database.

'''

from os import path
from urlparse import urlparse
from cgi import parse_qs
import ConfigParser
import logging
import traceback
import wsgiref.handlers

import libxml2
import libxslt

import rlib  # http://rlib.sicompos.com/
             # 06b3e629c6f99a8b2fd1264f32db8f56  rlib-1.3.7.tar.gz

PLAIN = [('Content-Type', 'text/plain')]
HTML8 = [('Content-Type', 'text/html; charset=utf-8')]
PDF = [('Content-Type', 'application/pdf')]

log = logging.getLogger(__name__)


def cgi_main():
    wsgiref.handlers.CGIHandler().run(trusted_handler)


def trusted_handler(env, start_response,
                    tx='reportspec.xsl',
                    ini='conf.ini',
                    section='_database',
                    dsn='local_mysql'):
    '''TCB part of the WSGI handler

    @param env: CGI environment; PATH_INFO is used to find
            a report skeleton under `templates`.
            
    See :func:`add_xataface_datasource` for database connection strategy.

    '''
    k = parse_qs(env.get('QUERY_STRING', '')).get('key')
    if not k:
        start_response('401 unauthorized', PLAIN)
        return ['missing key parameter ']

    here = path.dirname(__file__)

    opts = ConfigParser.SafeConfigParser()
    pc = PrefixConfig(File(here, ini), '[DEFAULT]')
    pc.feedto(opts)

    if opts.get(section, 'report_key') not in k:
        start_response('401 unauthorized', PLAIN)
        return ['report key does not match.']

    report = rlib.Rlib()
    # The report_key is authorization to open the database.
    add_xataface_datasource(report, dsn, opts, section)

    txpath = File(here, tx)

    template = File(path.join(here, 'templates'),
                    env.get('PATH_INFO', '')[1:] + '.html')
    if not template.exists():
        start_response('404 not found', PLAIN)
        return ['no such report spec\n']

    try:
        return serve_report_request(start_response, template,
                                    txpath, report, dsn)
    except:  # pylint: disable-msg=W0703,W0702
        start_response('500 internal error', PLAIN)
        return [traceback.format_exc()]


class Path(object):
    def __init__(self, dirpath, segment=None):
        self._dp = dirpath
        self._seg = segment

    def __str__(self, segment=None):
        if segment is None:
            segment = self._seg
        return path.join(self._dp, seg_ck(segment))


def seg_ck(fn):
    assert path.sep not in fn
    assert path.pathsep not in fn
    return fn


class Dir(Path):
    def subdir(self, segment):
        return Dir(path.join(self._dp, segment))

    def file(self, fn, ext):
        return File(self._dp, fn, ext)


class File(Path):
    def fp(self):
        return open(str(self))

    def exists(self):
        return path.exists(str(self))


def serve_report_request(start_response, template, txpath, report, dsn):
    '''Less trusted part of the WSGI handler.

    The caller is responsible to make 5xx responses out of any
    exceptions raised.

    @param start_response: as per WSGI; called with 200 OK.
    @param template: a report skeleton; The skeleton also specifies
                     the mysql query to run in an element with
                     @class="query".
    @param txpath: File of an XSLT transformation that produces
                  `rlib report definitions`__ from HTML skeletons.
    @param report: an intilized rlib__ report with datasource.
    @param dsn: data source name to associate with query.

    @return: an iterator as per WSGI; contains a PDF document.

    __ http://newrlib.sicom.com/~rlib/index.php/Documentation_XML
    __ http://rlib.sicompos.com/

    .. todo: cite WSGI
    '''

    tx = libxslt.parseStylesheetDoc(libxml2.parseFile(str(txpath)))

    skel = libxml2.parseFile(str(template))
    ctxt = skel.xpathNewContext()
    report_dml = ctxt.xpathEval('//*[@class="query"]')[0].content
    log.debug('report dml: %s', report_dml)
    report.add_query_as(dsn, report_dml, 'arbitrary_report_name')

    spec = tx.applyStylesheet(skel, None)
    spec_txt = spec.serialize()
    report.add_report_from_buffer(spec_txt)

    # todo: try different font:
    # report.set_output_parameter("pdf_fontname", 'helvetica')

    # I'm trying to get rid of:
    # encoding is NULL or invalid [C]... using en_US
    # but this doesn't seem to change anything.
    # myreport.set_output_encoding('UTF-8')
    report.set_output_format_from_text("PDF")
    report.execute()

    log.debug('raw headers: %s', report.get_content_type_as_text())
    hd_txt = report.get_content_type_as_text()
    hdrs = [tuple(line.strip().split(': ', 1))
            for line in hd_txt.split('\n')[:-1]]  # skip head/body separator
    log.debug('parsed headers: %s', hdrs)
    start_response('200 ok', hdrs)
    return [report.get_output()]


def add_xataface_datasource(report, dsn, opts, section):
    '''Add a mysql datasource to a report following xataface conventions.

    @param report: an rlib.Rlib
    @param dsn: a name for the datasource, per the rlib API
    @param opts: ConfigParser on `conf.ini`, per `xataface docs`__
    @param section: `_database`, per xataface

    __ http://xataface.com/wiki/conf.ini_file
    '''
    def opt(n):
        v = opts.get(section, n)
        return v[1:-1]  # strip ""s

    report.add_datasource_mysql(dsn, opt('host'), opt('user'),
                                opt('password'), opt('name'))


class PrefixConfig(object):
    '''work-around: xataface needs options before the 1st [section]
    '''
    def __init__(self, fpath, line):
        self._f = fpath
        self._l = line
        self._fp = None

    def feedto(self, opts):
        self._fp = self._f.fp()
        opts.readfp(self, str(self._f))

    def readline(self):
        if self._l:
            l = self._l
            self._l = None
            return l
        else:
            return self._fp.readline()


if __name__ == '__main__':
    cgi_main()
